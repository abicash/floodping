#include <stdlib.h>
#include <avr/io.h>
#include <avr/sleep.h>
#include <util/delay.h>
#include <avr/interrupt.h>

#define BIT(a) (1 << a)

#ifndef cbi
#define cbi(sfr, bit)     (_SFR_BYTE(sfr) &= ~_BV(bit))
#endif
#ifndef sbi
#define sbi(sfr, bit)     (_SFR_BYTE(sfr) |= _BV(bit))
#endif

uint8_t getcap(uint8_t pin, uint8_t sampletime, uint8_t waittime) {
	DDRB &= ~pin;
	while (waittime--) {
		__asm__ ("nop");
	}
	while (!(PINB & pin) && --sampletime)
		;
	DDRB |= pin;
	return sampletime;
}

ISR(TIMER0_COMPA_vect)
{
	OCR1A = rand() & 0xff;
}

int main() {
	//	while (1) {
	//		int i = 0;
	//		int n = 11;
	//		while (--n) {
	//			i += getcap(1 << PB3, 50, 40);
	//		}
	//		i /= 10;
	//		if (i < 42) {
	//			PORTB |= (1 << PB0);
	//		} else if (i > 45) {
	//			PORTB &= ~(1 << PB0);
	//		}
	//		_delay_ms(100);
	//	}


	PLLCSR = 0b00000110; /* Select PLL clock for TC1.ck */
	GTCCR  = 0b01100000; /* Enable TC1.OCB as PWM out (L-ch) */
	TCCR1  = 0b01100001; /* Start TC1 with TC1.OCA is enabled as PWM out (R-ch) */
	TCCR0A = 0b00000010; /* Enable TC0.ck = 2MHz as interval timer */
	TCCR0B = 0b00000010;
	TIMSK  = _BV(OCIE0A);

	while (1) {
//		PORTB |= (1 << PB0);
//		_delay_ms(rand() / 60000);
//		PORTB &= ~(1 << PB0);
//		_delay_ms(rand() / 60000);
	}

}
