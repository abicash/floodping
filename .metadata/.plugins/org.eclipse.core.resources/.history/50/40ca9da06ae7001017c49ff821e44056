#include <inttypes.h>
#include <avr/io.h>
#include <util/delay.h>
#include <avr/pgmspace.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <avr/eeprom.h>
#include <avr/sleep.h>
#include <avr/wdt.h>
#include <stdlib.h>
#include <string.h>

#include        "usiTwiSlave.h"

// Note: The LSB is the I2C r/w flag and must not be used for addressing!
#define         SLAVE_ADDR_ATTINY       0b10101010

//####################################################################### Macros

#define uniq(LOW,HEIGHT)        ((HEIGHT << 8)|LOW)                       // Create 16 bit number from two bytes
#define LOW_BYTE(x)             (x & 0xff)                                          // Get low byte from 16 bit number
#define HIGH_BYTE(x)            ((x >> 8) & 0xff)                         // Get high byte from 16 bit number
#define sbi(ADDRESS,BIT)        ((ADDRESS) |= (1<<(BIT)))       // Set bit
#define cbi(ADDRESS,BIT)        ((ADDRESS) &= ~(1<<(BIT)))// Clear bit
#define toggle(ADDRESS,BIT)     ((ADDRESS) ^= (1<<BIT)) // Toggle bit
#define bis(ADDRESS,BIT)        (ADDRESS & (1<<BIT))              // Is bit set?
#define bic(ADDRESS,BIT)        (!(ADDRESS & (1<<BIT)))         // Is bit clear?
//#################################################################### Variables

volatile long lWDTcounter = 0;
long lWDTmax = 0;

ISR(WDT_vect) {
	cli();
	wdt_enable(WDTO_15MS);
	lWDTcounter++;
	sei();
}

int main(void) {
	cli();
	wdt_reset();
	wdt_enable(WDTO_15MS);

	usiTwiSlaveInit(SLAVE_ADDR_ATTINY); // TWI slave init

	sei();

	while (1) {
		wdt_reset();

		if (lWDTcounter >= lWDTmax) {
			while (1) {
				wdt_reset();
				cli();
				if ((rxbuffer[3] == 0x99)) {
					sei();
					break;
				} else if ((rxbuffer[3] == 0xaa) && (rxbuffer[8] == 0xaa)) {
					rxbuffer[3] = 0;
					rxbuffer[8] = 0;

					lWDTmax = rxbuffer[4] | (rxbuffer[5] << 8)
							| (rxbuffer[6] << 16) | (rxbuffer[7] << 24);
				}
				sei();
				_delay_ms(1);
			}
			lWDTcounter = 0;
		}

		set_sleep_mode(SLEEP_MODE_PWR_DOWN);
		sleep_enable();

		sleep_cpu();
		sleep_disable();
		wdt_reset();
	}
}
